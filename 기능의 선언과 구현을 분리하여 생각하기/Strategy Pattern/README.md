# Strategy Pattern

- 정책이나 알고리즘을 교체하여 사용할 수 있음

* 아주 많이 사용되는 패턴
* 인터페이스에 선언된 기능을 구현한 다양한 정책을 다른 클래스에 영향을 주지 않고 추가, 삭제 할 수 있다.
* 각 기능에서 if -else 조건문을 구현하는 것이 아닌 정책 클래스를 선택하도록 구현하여 유지보수가 용이하다
* 클라이언트와 독립적인 다양한 알고리즘을 적용할 수 있도록 한다

**예제**

```
고객 센터에 전화 상담을 하는 상담원들이 있습니다.
일단 고객센터로 전화가 들어오면 대기열에 저장됩니다.
상담원이 지정되기 전까지 대기 상태가 됩니다.
각 고객의 전화를 상담원에게 배분하는 정책은 다음과 같이 여러 방식으로 구현될 수 있습니다.

1. 순서대로 배분하기 :
   모든 상담원이 동일한 건수를 처리하도록 들어오는 순서대로 배분합니다.
2. 짧은 대기열을 찾아 배분하기 :
   고객 대기 시간을 줄이기 위해 상담을 하지 않는 상담원이나 가장 짧은 대기 열을 보유한 상담원에게 배분합니다.
3. 우선 순위에 따라 배분하기 :
   고객의 등급에 따라 등급이 높은 고객의 전화를 우선 가져와 업무 능력이 좋은 상담원에게 우선 배분 합니다.

```

- 해당 소스에서 Scheduler를 구현하는 클래스들이 정책 클래스들이다.
- 사용하는 쪽(index.ts)에서는 어떤 경우에 무엇을 쓸 것이냐를 결정하는 거니까 여기는 if-else가 사용될 수 있다.
- 위에서 말한 if-else/switch-case가 줄어든다는 의미는 이 프로젝트의 소스코드처럼 class로 분리를 안하게 되면 아래처럼 각 메서드마다 if-else로 구분을 해줘야 한다.

  - 위에서 말한 '각 기능에서 if -else 조건문을 구현하는 것이 아닌 정책 클래스를 선택하도록 구현하여 유지보수가 용이하다' 이 부분에 대한 설명

  ```
      export class Scheduler {
          getNextCall() {
              if (roundrobin) {}
              else if (leastJob) {}
              else if (priority) {}
          }

          sendCallToAgent() {
              if (roundrobin) {}
              else if (leastJob) {}
              else if (priority) {}
          }
      }
  ```

- 리팩토링 할 때 코드에 반복되는 if-else조건이 있다면 class로 분리한다.
